# Fifteen

## <a href="fifteen.love">Download fifteen.love</a>

!

## Rules

There is a board with 15 pieces and an empty space. Move the pieces around until they are in sequential order by using the arrow keys to move pieces into the empty space.

## Controls

& *Arrow keys* & Move piece

## Overview

The pieces are stored as a grid of numbers.

The number 16 represents the empty space.

!

The other numbers are swapped with the empty space when an arrow key is pressed.

At the start of the game, the grid is initially sorted, and random moves are made. Setting the grid to random numbers instead could result in an unsolvable board.

After a piece has been moved, the pieces are looped through, and, if they all have their initial values, then the board is sorted and the game is over.

## Coding

### Drawing pieces

The pieces are drawn as squares.

For now, a piece is drawn where the empty space should be.

`
function love.draw()
    for y = 1, 4 do
        for x = 1, 4 do
            local pieceSize = 100
            local pieceDrawSize = pieceSize - 1
            love.graphics.setColor(100, 20, 150)
            love.graphics.rectangle(
                'fill',
                (x - 1) * pieceSize,
                (y - 1) * pieceSize,
                pieceDrawSize,
                pieceDrawSize
            )
        end
    end
end
`

!

### Drawing numbers

The piece numbers are drawn on top of the pieces.

The piece number is calculated by adding the X position (i.e. column number) to the Y position minus one (i.e. one less than the row number) multiplied by the number of pieces in a row.

For example, on the first row, nothing is added to the X position, so the first number on the first row is 1. On the second row, 4 is added to the X position, so the first number on the second row is 5.

`
function love.draw()
    for y = 1, 4 do
        for x = 1, 4 do
            local pieceSize = 100
            local pieceDrawSize = pieceSize - 1
            love.graphics.setColor(100, 20, 150)
            love.graphics.rectangle(
                'fill',
                (x - 1) * pieceSize,
                (y - 1) * pieceSize,
                pieceDrawSize,
                pieceDrawSize
            )
            |love.graphics.setColor(255, 255, 255)|
            |love.graphics.print(|
            |    x + ((y - 1) * 4),|
            |    (x - 1) * pieceSize,|
            |    (y - 1) * pieceSize|
            |)|
        end
    end
end
`

!

### Setting font

The font is set to size 30.

`
function love.load()
    love.graphics.setNewFont(30)
end
`

!

### Creating grid

A grid is created with each piece's number stored at its position on the grid, and this number is drawn.

The number of pieces on the X and Y axes are reused from drawing the pieces, so these are made into variables.

`
function love.load()
    --etc.

    gridXCount = 4
    gridYCount = 4

    grid = {}
    for y = 1, gridYCount do
        grid[y] = {}
        for x = 1, gridXCount do
            grid[y][x] = x + ((y - 1) * gridXCount)
        end
    end
end

function love.draw()
    for y = 1, |gridYCount| do
        for x = 1, |gridXCount| do
            -- etc.

            love.graphics.print(
                |grid[y][x]|,
                (x - 1) * pieceSize,
                (y - 1) * pieceSize
            )
        end
    end
end
`

### Not drawing the empty space

The number of pieces on each axis multiplied together gives the total number of pieces (in this case 4 times 4 makes a total of 16), and a piece is drawn only if it isn't this number.

`
function love.draw()
    for y = 1, gridYCount do
        for x = 1, gridXCount do
            |if grid[y][x] ~= gridXCount * gridYCount then|
                local pieceSize = 100
                local pieceDrawSize = pieceSize - 1
                love.graphics.setColor(100, 20, 150)
                love.graphics.rectangle(
                    'fill',
                    (x - 1) * pieceSize,
                    (y - 1) * pieceSize,
                    pieceDrawSize,
                    pieceDrawSize
                )
                love.graphics.setColor(255, 255, 255)
                love.graphics.print(
                    grid[y][x],
                    (x - 1) * pieceSize,
                    (y - 1) * pieceSize
                )
            |end|
        end
    end
end
`

!

### Finding position of empty space

The first step in moving the pieces is finding which of the spaces is empty.

When a key is pressed the grid is looped through, and, if a piece is equal to the the number of pieces on each axis multiplied together (i.e. it's the empty space), then, for now, its position is printed.

`
function love.keypressed(key)
    local emptyX
    local emptyY

    for y = 1, gridYCount do
        for x = 1, gridXCount do
            if grid[y][x] == gridXCount * gridYCount then
                emptyX = x
                emptyY = y
            end
        end
    end

    print('empty x: '..emptyX..', empty y: '..emptyY)
end
`

~
empty x: 4, empty y: 4
~

### Moving pieces down

For now, when a is key is pressed it swaps the empty space with the piece above it (i.e. minus 1 on the Y axis).

Currently this will error when a key is pressed and the empty space is at the top of the grid.

`
function love.keypressed(key)
    -- etc.

    grid[emptyY - 1][emptyX], grid[emptyY][emptyX] = 
    grid[emptyY][emptyX], grid[emptyY - 1][emptyX]
end
`

!

### Only move on Y axis if possible

If *grid[emptyY - 1]* is nil (i.e. *emptyY* is 1 so *emptyY - 1* is 0), then *grid[empty - 1][emptyX]* will cause an error because the *[emptyX]* part is trying to index nil.

To prevent this, moving is only possible if *grid[emptyY - 1]* is a non-nil value.

`
function love.keypressed(key)
    -- etc.

    |if grid[emptyY - 1] then|
        grid[emptyY - 1][emptyX], grid[emptyY][emptyX] =
        grid[emptyY][emptyX], grid[emptyY - 1][emptyX]
    |end|
end
`

### Moving pieces up

The piece that the empty space swaps with is made into a variable, and, when the up key is pressed it is set to the piece below the empty space (i.e. plus 1 on the Y axis).

`
function love.keypressed(key)
    -- etc.
 
    |local newEmptyY|
    |if key == 'down' then|
    |    newEmptyY = emptyY -  1|
    |elseif key == 'up' then|
    |    newEmptyY = emptyY +  1|
    |end|

    if grid[|newEmptyY|] then
        grid[|newEmptyY|][emptyX], grid[emptyY][emptyX] = 
        grid[emptyY][emptyX], grid[|newEmptyY|][emptyX]
    end
end
`

### Moving pieces left and right

The piece which the empty space swaps with is set on the X axis when the left or right arrow is pressed.

The X and Y positions of this piece are initially set to the space's position, so that if one of the axes is not changed it uses the same position on that axis as the empty space.

Currently this will error when the left/right key is pressed and the empty space is already at the rightmost/leftmost position.

`
function love.keypressed(key)
    -- etc.
 
    local newEmptyY |= emptyY|
    |local newEmptyX = emptyX|

    if key == 'down' then
        newEmptyY = emptyY -  1
    elseif key == 'up' then
        newEmptyY = emptyY +  1
    |elseif key == 'right' then|
    |    newEmptyX = emptyX -  1|
    |elseif key == 'left' then|
    |    newEmptyX = emptyX +  1|
    end

    if grid[newEmptyY] then
        grid[newEmptyY][|newEmptyX|], grid[emptyY][emptyX] = 
        grid[emptyY][emptyX], grid[newEmptyY][|newEmptyX|]
    end
end
`

!

### Only move on X axis if possible.

If *grid[newEmptyY][newEmptyX]* is nil (for example when *newEmptyX* is 0), then *grid[emptyY][emptyX]* will be assigned nil, and *love.graphics.print* will error when it is given nil instead of a number.

To prevent this, moving is only possible if *grid[newEmptyY][newEmptyX]* is a non-nil value.

`
function love.keypressed(key)
    -- etc.

    if grid[newEmptyY] |and grid[newEmptyY][newEmptyX]| then
        grid[newEmptyY][newEmptyX], grid[emptyY][emptyX] = 
        grid[emptyY][emptyX], grid[newEmptyY][newEmptyX]
    end
end
`

### Shuffling

At the beginning of the game, a number of random moves are made to shuffle the board.

A random number between 1 and 4 is generated and a move is made in one of the four movement directions based on this number.

`
function love.load()
    -- etc.

    |for moveNumber = 1, 1000 do|
        local emptyX
        local emptyY

        for y = 1, gridYCount do
            for x = 1, gridXCount do
                if grid[y][x] == gridXCount * gridYCount then
                    emptyX = x
                    emptyY = y
                end
            end
        end

        local newEmptyY = emptyY
        local newEmptyX = emptyX

        |local roll = love.math.random(4)|
        if |roll == 1| then
            newEmptyY = emptyY - 1
        elseif |roll == 2| then
            newEmptyY = emptyY + 1
        elseif |roll == 3| then
            newEmptyX = emptyX - 1
        elseif |roll == 4| then
            newEmptyX = emptyX + 1
        end

        if grid[newEmptyY] and grid[newEmptyY][newEmptyX] then
            grid[newEmptyY][newEmptyX], grid[emptyY][emptyX] = 
            grid[emptyY][emptyX], grid[newEmptyY][newEmptyX]
        end
    |end|
end
`

!

### Simplifying code

The only difference between the shuffling code and the keyboard controlled code is how the direction of the move is determined, so a function is made with the direction as a parameter.

`
function love.load()
    -- etc.

    |function move(direction)|
        local emptyX
        local emptyY

        for y = 1, gridYCount do
            for x = 1, gridXCount do
                if grid[y][x] == gridXCount * gridYCount then
                    emptyX = x
                    emptyY = y
                end
            end
        end

        local newEmptyY = emptyY
        local newEmptyX = emptyX

        if |direction == 'down'| then
            newEmptyY = emptyY -  1
        elseif |direction == 'up'| then
            newEmptyY = emptyY +  1
        elseif |direction == 'right'| then
            newEmptyX = emptyX -  1
        elseif |direction == 'left'| then
            newEmptyX = emptyX +  1
        end

        if grid[newEmptyY] and grid[newEmptyY][newEmptyX] then
            grid[newEmptyY][newEmptyX], grid[emptyY][emptyX] = 
            grid[emptyY][emptyX], grid[newEmptyY][newEmptyX]
        end
    end

    for moveNumber = 1, 1000 do
        local roll = love.math.random(4)
        if roll == 1 then
            |move('down')|
        elseif roll == 2 then
            |move('up')|
        elseif roll == 3 then
            |move('right')|
        elseif roll == 4 then
            |move('left')|
        end
    end
end

function love.keypressed(key)
    if key == 'down' then
        |move('down')|
    elseif key == 'up' then
        |move('up')|
    elseif key == 'right' then
        |move('right')|
    elseif key == 'left' then
        |move('left')|
    end
end
`

### Making the bottom-right position empty

So that the empty space always starts in the bottom-right corner, the pieces are moved left and up repeatedly. The number of pieces on an axis minus 1 is the maximum number of moves it would take to move the space from one side to the other.

`
function love.load()
    -- etc.

    for moveNumber = 1, gridXCount - 1 do
        move('left')
    end

    for moveNumber = 1, gridYCount - 1 do
        move('up')
    end
end
`

!

### Check for complete

After a move is made, the pieces are looped through, and if none of the pieces are not equal to the number they were initially given (i.e. they are all in the positions they were initially) then the game is complete.

For now, *love.load* is called to start a new game.

`
function love.keypressed(key)
    -- etc.

    local complete = true

    for y = 1, gridYCount do
        for x = 1, gridXCount do
            if grid[y][x] ~= ((y - 1) * gridXCount) + 1 then
                complete = false
            end
        end
    end

    if complete then
        love.load()
    end
end
`

### Simplifying code

The code for calculating the initial value of a piece is reused, so it is made into a function.

`
function love.load()
    -- etc.

    |function getInitialValue(x, y)|
    |    return x + ((y - 1) * gridXCount)|
    |end|

    grid = {}
    for y = 1, gridYCount do
        grid[y] = {}
        for x = 1, gridXCount do
            grid[y][x] = |getInitialValue(x, y)|
        end
    end

    -- etc.

function love.keypressed(key)
    -- etc.

    for y = 1, gridYCount do
        for x = 1, gridXCount do
            if grid[y][x] ~= |getInitialValue(x, y)| then
                complete = false
            end
        end
    end

    -- etc.
end
`

### Reshuffle if complete after shuffling

If the pieces are still in their initial order after shuffling, the shuffling process happens again.

The code for checking if the pieces are in their initial order is reused, so it is made into a function.

`
function love.load()
    -- etc.

    |function isComplete()|
        for y = 1, gridYCount do
            for x = 1, gridXCount do
                if grid[y][x] ~= getInitialValue(x, y) then
                    |return false|
                end
            end
        end
        |return true|
    |end|

    |repeat|
        for moveNumber = 1, 1000 do
            local roll = love.math.random(4)
            if roll == 1 then
                move('down')
            elseif roll == 2 then
                move('up')
            elseif roll == 3 then
                move('right')
            elseif roll == 4 then
                move('left')
            end
        end

        for moveNumber = 1, gridXCount - 1 do
            move('left')
        end

        for moveNumber = 1, gridYCount - 1 do
            move('up')
        end
    |until not isComplete()|
end

function love.keypressed(key)
    if key == 'down' then
        move('down')
    elseif key == 'up' then
        move('up')
    elseif key == 'right' then
        move('right')
    elseif key == 'left' then
        move('left')
    end

    if |isComplete()| then
        love.load()
    end
end
`

### Resetting

When the game is over only some variables need to be reset, so a function is made.

`
function love.load()
    love.graphics.setNewFont(30)
    
    gridXCount = 4
    gridYCount = 4

    function getInitialValue(x, y)
        -- etc.
    end
    
    function move(direction)
        -- etc.
    end

    function isComplete()
        -- etc.
    end

    |function reset()|
        grid = {}
        for y = 1, gridYCount do
            grid[y] = {}
            for x = 1, gridXCount do
                grid[y][x] = getInitialValue(x, y)
            end
        end

        repeat
            for moveNumber = 1, 1000 do
                local roll = love.math.random(4)
                if roll == 1 then
                    move('down')
                elseif roll == 2 then
                    move('up')
                elseif roll == 3 then
                    move('right')
                elseif roll == 4 then
                    move('left')
                end
            end

            for moveNumber = 1, gridXCount - 1 do
                move('left')
            end

            for moveNumber = 1, gridYCount - 1 do
                move('up')
            end
        until not isComplete()
    |end|

    |reset()|
end

function love.keypressed(key)
    -- etc.
    
    if isComplete() then
        |reset()|
    end
end
`

## Final code

`
function love.load()
    love.graphics.setNewFont(30)
    
    gridXCount = 4
    gridYCount = 4

    function getInitialValue(x, y)
        return x + ((y - 1) * gridXCount)
    end
    
    function move(direction)
        local emptyX
        local emptyY

        for y = 1, gridYCount do
            for x = 1, gridXCount do
                if grid[y][x] == gridXCount * gridYCount then
                    emptyX = x
                    emptyY = y
                end
            end
        end

        local newEmptyY = emptyY
        local newEmptyX = emptyX

        if direction == 'down' then
            newEmptyY = emptyY -  1
        elseif direction == 'up' then
            newEmptyY = emptyY +  1
        elseif direction == 'right' then
            newEmptyX = emptyX -  1
        elseif direction == 'left' then
            newEmptyX = emptyX +  1
        end

        if grid[newEmptyY] and grid[newEmptyY][newEmptyX] then
            grid[newEmptyY][newEmptyX], grid[emptyY][emptyX] = 
            grid[emptyY][emptyX], grid[newEmptyY][newEmptyX]
        end
    end

    function isComplete()
        for y = 1, gridYCount do
            for x = 1, gridXCount do
                if grid[y][x] ~= getInitialValue(x, y) then
                    return false
                end
            end
        end
        return true
    end

    function reset()
        grid = {}
        for y = 1, gridYCount do
            grid[y] = {}
            for x = 1, gridXCount do
                grid[y][x] = getInitialValue(x, y)
            end
        end

        repeat
            for moveNumber = 1, 1000 do
                local roll = love.math.random(4)
                if roll == 1 then
                    move('down')
                elseif roll == 2 then
                    move('up')
                elseif roll == 3 then
                    move('right')
                elseif roll == 4 then
                    move('left')
                end
            end

            for moveNumber = 1, gridXCount - 1 do
                move('left')
            end

            for moveNumber = 1, gridYCount - 1 do
                move('up')
            end
        until not isComplete()
    end

    reset()
end

function love.draw()
    for y = 1, gridYCount do
        for x = 1, gridXCount do
            if grid[y][x] ~= gridXCount * gridYCount then
                local pieceSize = 100
                local pieceDrawSize = pieceSize - 1
                love.graphics.setColor(100, 20, 150)
                love.graphics.rectangle(
                    'fill',
                    (x - 1) * pieceSize,
                    (y - 1) * pieceSize,
                    pieceDrawSize,
                    pieceDrawSize
                )
                love.graphics.setColor(255, 255, 255)
                love.graphics.print(
                    grid[y][x],
                    (x - 1) * pieceSize,
                    (y - 1) * pieceSize
                )
            end
        end
    end
end

function love.keypressed(key)
    if key == 'down' then
        move('down')
    elseif key == 'up' then
        move('up')
    elseif key == 'right' then
        move('right')
    elseif key == 'left' then
        move('left')
    end
    
    if isComplete() then
        reset()
    end
end
`
